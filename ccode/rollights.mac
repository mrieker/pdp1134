;;    Copyright (C) Mike Rieker, Beverly, MA USA
;;    www.outerworldapps.com
;;
;;    This program is free software; you can redistribute it and/or modify
;;    it under the terms of the GNU General Public License as published by
;;    the Free Software Foundation; version 2 of the License.
;;
;;    This program is distributed in the hope that it will be useful,
;;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;    GNU General Public License for more details.
;;
;;    EXPECT it to FAIL when someone's HeALTh or PROpeRTy is at RISk.
;;
;;    You should have received a copy of the GNU General Public License
;;    along with this program; if not, write to the Free Software
;;    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
;;
;;    http://www.gnu.org/licenses/gpl-2.0.html

;   $ make rollights.lst
;   $ ./z11ctrl
;   > pin set fpgamode 1	;# for using simulator
;   > pin set fpgamode 2	;# for using real pdp
;   > pin set bm_enablo 0xFFFF	;# to enable fpga main memory
;   > pin set kw_enable 1	;# to enable fpga line clock
;   > pin set ky_enable 1	;# to enable fpga switch register
;   > pin set ky_switches 180	;# steps between direction reversal
;   > hardreset			;# make sure processor stopped
;   > loadlst rollights.lst	;# load binary code
;   > hardreset			;# load power up vector
;   > flickcont			;# start it running

	SWLI = 177570		; switch & light register
	LKCS = 177546		; line clock status register
	IPS  = 4		; interrupts per light step

	.asect

	. = 000006
	wait
	jmp	@r2

	. = 000014
	wait
	jmp	@r2

	. = 000024
	.word	pwrup		; power up vector
	.word	000000

	. = 000030
	wait
	jmp	@r2

	. = 000060
	wait
	jmp	@r2

	. = 000100
	.word	lkint		; line clock interrupt
	.word	000340

	. = 000140
	wait
	jmp	@r2

	. = 000300
	wait
	jmp	@r2

	. = 000600
	wait
	jmp	@r2

	. = 001400
	wait
	jmp	@r2

	. = 003000
	wait
	jmp	@r2

	. = 006000
	wait
	jmp	@r2

	. = 014000
	wait
	jmp	@r2

pwrup:
	mov	#stack,sp	; initial stack pointer
	mov	#100002,r0	; data register contents
	mov	r0,r1		; address register contents
	mov	#stepccw,r2	; stepping direction
	mov	#IPS,r4		; interrupts per step
	clr	r5		; count the steps in initial direction
	mov	#000100,@#LKCS	; enable line clock interrupt
	jmp	@r1

	; step lights counter-clockwise
stepccw:
	asl	r1		; rotate address<15:01> left one bit
	bcc	100$
	add	#2,r1
100$:
	mov	r0,r3		; rotate data<15:01> right one bit
	bic	#177775,r3
	cmp	#1,r3
	ror	r0
	bic	#1,r0
	mov	#IPS,r4		; reset interrupts per step counter
	inc	r5
	mov	r5,@#SWLI
	cmp	r5,@#SWLI
	blos	200$
	mov	#stepcw,r2
200$:
	jmp	@r1		; jump to wait at correct address

	; step lights clockwise
stepcw:
	asl	r0		; rotate data<15:01> left one bit
	bcc	100$
	add	#2,r0
100$:
	mov	r1,r3		; rotate address<15:01> right one bit
	bic	#177775,r3
	cmp	#1,r3
	ror	r1
	bic	#1,r1
	mov	#IPS,r4		; reset interrupts per step counter
	dec	r5
	mov	r5,@#SWLI
	bne	200$
	mov	#stepccw,r2
200$:
	jmp	@r1		; jump to wait at correct address

	; line clock interrupt handler
lkint:
	cmp	@(sp),(pc)+	; see if interrupting just after the wait
		jmp	@r2
	bne	100$		; if not, don't count the interrupt
	dec	r4		; if so, see if interrupted enough times
	beq	100$		; if so, return to do the jmp @r2
	sub	#2,@sp		; if not, repeat the wait
100$:
	rti

	. = 030000
stack:
	wait
	jmp	@r2

	. = 060000
	wait
	jmp	@r2

	. = 140000
	wait
	jmp	@r2

	. = 100002
	wait
	jmp	@r2

	.end
